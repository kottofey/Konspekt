```table-of-contents
```

У JS есть основной поток (Main Thread). Он линеен, в нем нет гонки разных процессов, все они идут друг за другом по очереди. И если какой-то из процессов вешается - он вешает весь Основной поток. Не происходит отрисовка страницы и так далее.

Существуют также дополнительные потоки, они асинхронны, выполняются вне основного потока. Мы не знаем когда каждый процесс закончится. А когда он таки заканчивается -- он возвращается с информацией о выполнении в основной поток.

Возьмем для примера функцию setTimeout. Выглядит вот так:
```js
setTimeout(callback, ms);
```

Функция ждёт `ms` миллисекунд и затем выполняет `callback`. Прикол в том, что это всё должно выполниться в параллели с основным потоком. Выполняются следующие шаги:
1) Ждём `ms` миллисекунд
2) Ставим в очередь на запуск следующие шаги:
	1) Запустить коллбек

Пункт `2)` это очередь макро-задач (Macro Tasks)

Собственно, Event Loop выглядит следующим образом:
![[Pasted image 20240829005825.png]]
Посередине находится собственно бесконечный цикл - Основной поток. По нему по кругу носится бегунок-выполнятор задач и смотрит не открылась ли заслонка налево или направо.

Слева находится очередь макрозадач (Macro Tasks). Туда попадают в очередь, например, события, `setTimeout` или другие отложенные задачи. Они могут накапливаться и если бегунок зашел в левую область макрозадач он оттуда не выйдет, пока не выполнится весь накопившийся стек макрозадач. И это может стать проблемой, потому что задача может попасться тяжелой и выполняться долго. А значит бегунок не попадёт в правую часть - отрисовку страницы. Заслонка в эту часть открывается, как только в очереди макрозадач что-то появляется.

Правая часть -- это цикл рендера или отрисовки страницы. В нём есть несколько подзадач, которые выполняются по циклу - Style, Layout, Paint. То есть, браузер смотрит какие стили прописаны, потом применяет их к разметке и следом уже отрисовывает кадр. Это происходит с частотой 60 FPS. То есть, 60 раз в секунду. Если посчитать, то 1000 мс / 60 раз ≈ 16 мс, то есть, отрисовка происходит примерно раз в 16 миллисекунд. 

Есть, например, вот такой код:
```js
document.body.apendChild(el);
el.style.display = 'none';
```
Он выполнится корректно и стили применятся вовремя, без мерцания, несмотря на то, что стили прописаны после создания элемента. Не получится такого, что мы идём по коду, отрисовали элемент - он появился на странице, а потом следующей строкой убрали его через `display: none`. Сначала выполнится код в основном потоке, а потом на этапе рендера мы просчитаем стили, поймём, что у элемента `display: none` (этап Style), потом вставим его в разметку (этап Layout), а потом только отрисуем страницу (этап Paint). И элемент "появится" в разметке уже спрятанным.

Следующий код заблокирует вкладку бесконечным циклом:
```js
button.addEventListener('click', event => {
	while(true);
});
```

Клик по этой кнопке поставит событие в очередь макрозадач и при очередном цикле, когда откроется заслонка, браузер впадёт в бесконечный цикл. Цикл рендера не происходит, если накопятся еще какие-то коллбеки и макрозадачи, они всё-равно не выполнятся потому что браузер будет занят бесконечным циклом.

А что произойдёт, если поменяем код на похожий вроде бы по смыслу:
```js
function loop() {
	setTimeout(loop, 0);
}
loop();
```
Вроде бы тоже бесконечный цикл ибо рекурсия без точек выхода. НО! Отличие в следующем. `setTimeout` планирует макрозадачу-рекурсию в очередь макрозадач. На очередном цикле бегунок заходит в очередь макрозадач, тут же выполняет таймаут и сразу планирует следующий таймаут в очередь макрозадач. И выходит в основной поток. На следующем витке опять заходит в очередь макрозадач, опять выполняет и тут же планирует таймауты и выходит. Всё работает. На каком-то витке приходит очередь рендера страницы, бегунок проходит по правому витку, отрисовывает кадр и возвращается в основной цикл где видит, что опять есть очередь макрозадач, заходит туда и так далее. Ничего не виснет, всё работает.

# Request Animation Frame
Иногда возникает необходимость выполнить код в правом витке на этапе рендера. Для этого есть метод `requestAnimationFrame` или `rAF`.

Для примера будем двигать квадратик разными способами. Первый способ - через `rAF`
```js
function callback() {
	moveBoxOnePixelForward();
	requestAnimationFrame(callback);
}
callback();
```
Запускаем на последней строке нашу функцию и она входит в рекурсию, передвигая бокс вправо по одному пикселю каждый раз. Заменим `rAF` на `setTimeout`

```js
function callback() {
	moveBoxOnePixelForward();
	setTimeout(callback, 0);
}
callback();
```
Бокс будет двигаться гораздо быстрее версии с `rAF`. Потому что коллбеки успевают выполниться несколько раз между запросами на рендер страницы. Примерно четыре коллбека на один кадр.

> Интересный факт. Рендер не происходит, если в этом нет необходимости. Например, курсор не двигается или на странице ничего не меняется или вообще вкладка свернута или неактивна.

> Другой интересный факт. Рендер происходит 60 раз в секунду, но если мы будем менять стили 1000 раз в секунду, то они не будут меняться на странице 1000 раз в секунду, вычислится текущее актуальное значение на момент рендера и применится именно оно.

Если запихивать задачи по перемещению бокса вправо в очередь макрозадач без таймаутов или `rAF`, то бокс будет перемещаться абсолютно хаотично.

Что происходит:

![[Pasted image 20240829021003.png]]

в самом начале кадра происходит вычисление стилей и отрисовка (оранжевое и зеленое). Далее до следующей отрисовки могут вставляться макрозадачи (желтые). Причём, невозможно предсказать сколько их будет и какой длительности они будут. Единственное - то, что они выполняться будут в том порядке, в котором были поставлены в очередь.

Если взять таймауты, то они распределены практически равномерно, по 4 штуки в каждом кадре.

![[Pasted image 20240829021530.png]]

Но первые три как бы бесполезные и не будут браться в расчет, берется в расчет только последний.

![[Pasted image 20240831002631.png]]
Именно поэтому отрисовка через таймаут была быстрее, потому что отбрасывались первые три таймаута. 

setTimeout не слишком хорош для выполнения подобных задач. Например, один из таймаутов мог не успеть выполниться и залезть в следующий кадр:

![[Pasted image 20240831002820.png]]
Выходит, что в третьем кадре появился бессмысленный таймаут, который не будет браться в расчет, а вот второй кадр выпал из рендера и появилась просадка.

Другой вариант, таймаут мог выполняться дольше, чем задано, ведь он задаёт МИНИМАЛЬНО ГАРАНТИРОВАННУЮ задержку:

![[Pasted image 20240831003812.png]]

В итоге, рендер второго кадра задержался и опять дёргающаяся картинка.

А если использовать `requestAnimationFrame`, то все коллбеки переходят в начало кадра до отрисовки. И пока они не занимают слишком много времени, чтобы не вылезти за пределы одного кадры, то всё будет выполняться плав-нень-ко

![[Pasted image 20240831004730.png]]

Еще один пример. Мы много раз меняем `display` для бокса по клику по кнопке:

```js
button.addEventListener('click', () => {
	box.style.display = 'none';
	box.style.display = 'block';
	box.style.display = 'none';
	box.style.display = 'block';
	box.style.display = 'none';
	box.style.display = 'block';
	box.style.display = 'none';
	box.style.display = 'block';
	box.style.display = 'none';
})
```

Как это работает. JS будет смотреть на последнее значение свойства и именно оно пойдёт на отрисовку, а остальные не берутся в учёт.

Пример. Нам надо передвинуть бокс на 1000px право, а следом вернуть на 500px влево.

```js
button.addEventListener('click', () => {
	box.style.transform = 'translateX(1000px)';
	box.style.transition = 'transform 1s ease-in-out';
	box.style.transform = 'translateX(500px)';
})
```

В таком варианте бокс сдвинется только на 500px вправо без промежуточной точки в 1000px, потому что код выполнится синхронно. JS пройдется по всему коду, поймет, что смысла применять 1000px нет и применится только последнее значение.

Можно попробовать завернуть последнее перемещение на 500px в requestAnimationFrame.
```js ln=true
button.addEventListener('click', () => {
	box.style.transform = 'translateX(1000px)';
	box.style.transition = 'transform 1s ease-in-out';

	requestAnmationFrame(() => {
		box.style.transform = 'translateX(500px)';
	});
});
```
Но это не поможет. Казалось бы, мы запросили отрисовку на следующем кадре. Но происходит всё вот так. 

Идём по коду, на строках `2` и `3` мы выполняем макрозадачу от `addEventListener` и вычисляем передвинуть бокс на 1000 пикселей и применяем плавную анимацию. Едем на отрисовку. На строках `5-7` случается `requestAnimatiuonFrame`, где мы хотим передвинуть бокс на 500 пикселей, это дело видит, что финальное значение положения бокса будет таки 500 пикселей и затирает результат прошлого кода.

Как исправить?

Можно завернуть `rAF` в еще оджин `rAF` или перед последним передвижением на 500 пикселей применить стили через `getComputedStyle(box).transform`. 

```js
button.addEventListener('click', () => {
	box.style.transform = 'translateX(1000px)';
	box.style.transition = 'transform 1s ease-in-out';

	requestAnmationFrame(() => {
		requestAnmationFrame(() => {
			box.style.transform = 'translateX(500px)';
		});
	});
});

// ИЛИ //

button.addEventListener('click', () => {
	box.style.transform = 'translateX(1000px)';
	box.style.transition = 'transform 1s ease-in-out';
	getComputedStyle(box).transform;
	box.style.transform = 'translateX(500px)';
})
```

В первом случае вместо того, чтобы затереть значение первого сдвига бокса мы планируем перерисовку на следующий фрейм.

В некоторых браузерах есть прикол, что этап `rAF` может находиться ПОСЛЕ отрисовки кадра, то есть, после этапов Style, Layout, Paint. В частности замечено за Сафари.

# Микрозадачи

Для микрозадач есть своя отдельная очередь в процессе исполнения Event Loop. Они могут возникнуть КОГДА УГОДНО. Они прервут основной поток и начнут выполняться из стека микрозадач одна за одной пока стек не опустеет. И только затем продолжится выполняться основной поток. 

Источник микрозадач - Промисы. 

# Особенности циклов `forEach` и `for of`

```javascript
async function foo() {
 someArray.forEach(function (value) {
   doSomethingAsync(value);
 });
}
```

Пока что всё хорошо, мы параллельно выполняем `doSomethingAsync` несколько раз, так как мы не используем `await`. Но как бы мы это выполнили с ним?

Явно не так:

```javascript
async function foo() {
 someArray.forEach(function (value) {
   await doSomethingAsync(value);
 });
}
```

Пример выше выдаст синтаксическую ошибку, так как мы передаем `forEach` синхронную функцию.

Не проблема, верно? Нам всего-лишь надо передать ей `async` функцию. А вот и нет.

```javascript
async function foo() {
 someArray.forEach(async function (value) {
   await doSomethingAsync(value);
 });
}
```

Что тут не так? Давайте посмотрим на то, как это интерпретируется. Я не будут многословным с промисами и объясню максимально просто то, как это было бы в случае с ними:

```javascript
function foo() {
  someArray.forEach(function () {
    // отдаётся промис
    return doSomethingAsync(value);
  });
}
```

Проблема в том, что `forEach` не ожидает `async` функции или выражаясь промисами, она не ждет пока одна итерация вернет промис, чтобы завершить предыдущую.

Также, в наших примерах, нам не надо было ожидать вызова `forEach`.

Так как теперь решить эту проблему? К сожалению, мы не можем использовать `forEach`. По факту, никакие синхронные итераторы не будут работать. Нам нужны итераторы, которые знают как работать с промисами.

И есть один, который будет. Это современная версия цикла for, “`for of`”, которая понимает `await` для промисов.

Это сработает:

```javascript
for (item of someArray) {
 await foo();
}
```

Если вы не можете использовать “`for of`”, то вы можете применить итератор, который поддерживает промисы или использовать библиотеку, такую как [bluebird](http://bluebirdjs.com/docs/api/promise.each.html) Promise.each