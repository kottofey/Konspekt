```table-of-contents
```
Они пришли с выходом стандарта ES6 (или ES5, не уверен...)

```js title="Синтаксис"
let func = (arg1, arg2, ...argN) => expression;
```
## Методы объявления
Обычно функция присваивается переменной:
```js
const plus = (x, y) => x + y;

// Эквивалентно //

function plus(x, y) {
	return x + y;
}
```

Еще варианты:
```js
// Вариации с количеством аргументов
const noArgs = () => console.log('Hellow No Args!');
const singleArg = x => console.log(`x: ${x}`);

// Аргумент по-умолчанию
const singleArg = (x = 1) => console.log(`x: ${x}`);

// Сложные функции с несколькими действиями
const moreActions = (a, b) => {
	a *= 2;
	b *= 3;
	
	return a + b; // в многострочных функциях обязателен return!
}
```

Если хотим вернуть объект:
```js
const returnObj = (str = '') => {
	return {
		value: str,
		length: str.length
	}
}

// Можно сократить и убрать ключевое слово return
// Так как и тело функции, и боъект заключены в фигурные скобки, то надо возвращаемый объект обернуть в круглые скобки, чтобы нтерпретатор разобрался что к чему.
const returnObj = (str = '') => ({
		value: str,
		length: str.length
});
```

## Отличия от обычной функции
- У обычной функции есть скрытая псевдоколлекция `arguments`, которая содержит все аргументы, что были переданы в функцию. Даже те, которые не были явно переданы в параметры. 

```js
function foo (x, y) {
	console.log(arguments); // выведет содержимое псевдоколлекции arguments
	return x + y;
}
```

**Такой коллекции нет у стрелочной функции.**

- У стрелочной функции нет своего контекста. Она использует контекст с уровня выше.
```js
const obj = {
  firstName: 'Roma',
  age: 30,
  
  getFirstName() {
    console.log(this); // выведет this для
  },
  
  arrowGetAge: () => console.log(this),

  arrowFixGetAge: null,
  
  getAge() {
    this.arrowFixGetAge = () => console.log(this);
    // setTimeout(() => console.log(this)); // как вариант, можно положить стрелочную функцию в колбэк setTimeout()
  },
}

obj.getFirstName(); // выведет this для obj, т.к. обычная функция
obj.arrowGetAge(); // выведет this для объекта window, т.к. контекст объекта obj был утерян для стрелочной функции

obj.getAge(); // вызываем обычную функцию для создания контекста и присвоения его стрелочной функции. По сути -- это замыкание.
obj.arrowFixGetAge(); // Вызываем стрелочную функцию, которая теперь использует контекст объекта, присвоенный строкой выше.
```

- Стрелочные функции нельзя использовать с `new`
Отсутствие `this` естественным образом ведёт к другому ограничению: стрелочные функции не могут быть использованы как конструкторы. Они не могут быть вызваны с `new`.

- Стрелочные функции VS bind

Существует тонкая разница между стрелочной функцией `=>` и обычной функцией, вызванной с `.bind(this)`:
	- `.bind(this)` создаёт «связанную версию» функции.
	- Стрелка `=>` ничего не привязывает. У функции просто нет `this`. При получении значения `this` – оно, как обычная переменная, берётся из внешнего лексического окружения.

