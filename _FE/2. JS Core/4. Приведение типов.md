```table-of-contents
title: 
style: nestedList # TOC style (nestedList|nestedOrderedList|inlineFirstLevel)
minLevel: 0 # Include headings from the specified level
maxLevel: 0 # Include headings up to the specified level
includeLinks: true # Make headings clickable
debugInConsole: false # Print debug info in Obsidian console
```
В JavaScript существует лишь 3 типа конвертации: в строку, в число или в логическое значение.

Из-за того, что JavaScript умеет изменять тип операндов на лету, он называется языком со _слабой типизацией_.

Что будет, если использовать операнды разного типа?
```js
'Время, мин: ' + 50; // Результат: 'Время, мин: 50'
'2' * 50;            // Результат: 100
```

JavaScript попытается привести операнды к одному типу и выполнить операцию. Подходящий тип будет выбираться в зависимости от операции.

Плюс может быть знаком сложения или конкатенации, но так как один из операндов — строка, то сложение не подходит. Поэтому число `50` приводится к строке `'50'` и склеивается со строкой `'Время, мин: '`.

Звёздочка — это знак умножения, со строками она не используется. Поэтому JavaScript пытается превратить строку `'2'` в число, и ему это удаётся. Затем числа `2` и `50` перемножаются, и получается `100`.
# Приведение типов для примитивов
## Приведение к строке
Явно преобразовать в строку можно применив обёртку `String('value')`.

Неявно преобразовывается если используется знак `+` и один из двух операндов является строкой. Если операндов больше двух, то идём слева направо, складываем числа пока не встретим строку. результирующее число до строки превращаем также в строку и далее всё считаем строками, даже если там числа.

```js
1 + 2 + '3' + 4 // '334'
'1' + 2 + 3 + 4 // '1234'
1 + 2 + 3 + '4' // '64'
```

## Приведение к логическому типу

Чтобы привести явно к булеву типу есть функция `Boolean()`, аргумент приводится к булеву типу.
```js
Boolean('')           // false
Boolean(0)            // false     
Boolean(-0)           // false
Boolean(NaN)          // false
Boolean(null)         // false
Boolean(undefined)    // false
Boolean(false)        // false
```

```js
Boolean({})             // true
Boolean([])             // true
Boolean(Symbol())       // true
!!Symbol()              // true
Boolean(function() {})  // true
```

В условии все значения приводятся к логическому типу. Поэтому мы можем использовать в качестве условий любые значения: числа, строки, `true` и `false`, а также переменные, которые содержат такие данные.

Все числа, кроме нуля, — `true`, при этом `0` — `false`
Все строки, кроме пустой строки, — `true`, пустая строка `''` — `false`

Можно сказать, что значения, которые как бы ничего в себе не содержат (как `0` или пустая строка `''`), приводятся к `false`, а все остальные приводятся к `true`.

Неявно приводится, если используется логический контекст или операторы сравнения `&&`, `||` или `!`. Что интересно, первые два выполняют преобразование значений к логическому типу для внутренних целей, а возвращают значения исходных операндов, даже если они не являются логическими.

[Хорошая статейка по приведению типов](https://doka.guide/js/typecasting)

## Приведение к числу
Чтобы явно превратить строку в число, используют команду `Number`:
```js
Number(строка);
```

Неявное преобразование к типу `Number` выполняют следующие операторы:
- Операторы сравнения (`>`, `<`, `<=`, `>=`).  
- Побитовые операторы (`|`, `&`, `^`, `~`).  
- Арифметические операторы (`-`, `+`, `*`, `/`, `%`). Обратите внимание на то, что оператор `+` с двумя операндами не вызывает неявное преобразование к числовому типу, если хотя бы один оператор является строкой.  
- Унарный оператор `+`.  
- Оператор нестрогого равенства `==` (а также `!=`). Обратите внимание на то, что оператор `==` не производит неявного преобразования в число, если оба операнда являются строками.

| Числа          | Преобразуется в...                                                                                                                                                                                                                      |
| -------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `undefined`    | `NaN`                                                                                                                                                                                                                                   |
| `null`         | `0`                                                                                                                                                                                                                                     |
| `true / false` | `1` / `0`                                                                                                                                                                                                                               |
| `string`       | Пробельные символы (пробелы, знаки табуляции `\t`, знаки новой строки `\n` и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем `0`, иначе из непустой строки «считывается» число. При ошибке результат `NaN`. |
При применении оператора `==` к `null` или `undefined` преобразования в число не производится. Значение `null` равно только `null` или `undefined` и не равно ничему больше.
# parseInt, parseFloat
Функция парсит число целое или с плавающей точкой из строки. При этом, нужно, чтобы число было в начале строки и перед ним не было других не-чисел.
![[parseInt и parseFloat]]

# Приведение типов для объектов

> **Помни!** Массивы это разновидность объектов!

Сначала объект преобразуется к примитиву, а потом уже над примитивами выполняются действия. На выходе получается тоже примитив.

JS решает к чему именно приводить с помощью хинтов. Они бывают `string` `number` и `default`. 

**Чтобы выполнить преобразование, JavaScript пытается найти и вызвать три следующих метода объекта:**

1. Вызвать `obj[Symbol.toPrimitive](hint)` – метод с символьным ключом `Symbol.toPrimitive` (системный символ), если такой метод существует,
2. Иначе, если хинт равен `"string"`
    - попробовать вызвать `obj.toString()` или `obj.valueOf()`, смотря какой из них существует.
3. Иначе, если хинт равен `"number"` или `"default"`
    - попробовать вызвать `obj.valueOf()` или `obj.toString()`, смотря какой из них существует.

Метод `obj[Symbol.toPrimitive](hint)` переопределяет каким образом мы хотим преобразовать объект в зависимости от хинта. Этот метод прописывается вручную в объекте. Если такой метод существует, то второй и третий пункты не выполняются, а используется переопределенный способ.

```javascript
let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// здесь определен метод Symbol.toPrimitive
// демонстрация результатов преобразований:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
```

## toString/valueOf

Если нет `Symbol.toPrimitive`, тогда JavaScript пытается найти методы `toString` и `valueOf`:

- Для хинта `"string"`: вызвать метод `toString`, а если он не существует или возвращает объект вместо примитивного значения, то `valueOf` (таким образом, `toString` имеет приоритет при строковом преобразовании).
- Для других хинтов: вызвать метод `valueOf`, а если он не существует или возвращает объект вместо примитивного значения, то `toString` (таким образом, `valueOf` имеет приоритет для математических операций).

## Приведение к Boolean
Здесь всё просто. Любой объект или массив приводится к `true`. Даже пустой. 
