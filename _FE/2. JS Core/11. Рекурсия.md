Рекурсия это когда функция вызывает сама себя.

Бывает:
- Хвостовая рекурсия, когда в конце рекурсивной функции она вызывает сама себя
- Косвенная рекурсия, когда есть две (или более функции) и одна вызывает вторую, вторая вызывает первую и так по кругу.
**Обязательно нужна точка выхода из рекурсии, чтобы не получить бесконечный цикл.**

В рекурсивной функции бывает два случая:
- Рекурсивный, когда функция вызывает саму себя
- Граничный, когда функция перестает себя вызывать. Это и есть точка выхода из рекурсии

## Стек вызовов
Рекурсивная функция использует стек вызовов. Можно его сравнить со стопкой книг, которые мы выкладываем из шкафа. Каждую новую мы кладём наверх, а когда нужно что-то с книгами сделать, то всегда берем самую верхнюю. Рассмотрим на примере вычисления факториала числа.

```js
function fact(x) {
  if (x == 1) {  
    return 1;  
  } else {      
    return x * fact(x-1);
  }
}

console.log(fact(3));
```

Будем перебирать все цифры уменьшая на единицу каждый раз пока не доберемся до финальной "единицы". И каждый раз, пока `x` не равняется единице будем рекурсивно вызывать функцию. Когда доберемся до единицы, это только конец погружения в стек. Ни одна функция стека еще не завершила своей работы, не вернула ничего. Как только добрались до базового/граничного случая и рекурсия больше не вызывается, самый верхний элемент стека возвращает свой результат в элемент ниже него, затем следующий элемент возвращает свой результат в элемент ниже него и так далее, пока не доберемся до самого первого элемента, который и вернет финальный результат рекурсивной функции. Данный стек работает по принципу FILO (First In Last Out)

![[bkosaoej.bmp]]

## Пример 1
Выведем в консоль числа от 0 до 10:

```js ln=true
let i = 0;

function func() {
	console.log(i++);
	
	if (i <= 10) {
		func();
	}
}

func();
```

1) Объявляем переменную и присваиваем ей значение 0.
3) Описываем функцию с рекурсией.
11) Запускаем эту функцию:
4) Выводим 0 и увеличиваем переменную на 1 (i = 1)
6) Проверяем, меньше ли десяти переменная. На первой итерации она равна 1 -> истина, значит...
7) ...заново вызываем функцию и идём на шаг 4.

> ***Доходим до шага, когда i = 10...***

4) Выводим 10 и увеличиваем переменную на 1 (i = 11)
6) Смотрим, что i > 10, значит, ложь -> выходим из рекурсии
## Пример 2
Выведем элементы массива в консоль
```js
function func(arr) {
	console.log(arr.shift());

	if (arr.lrngth != 0) {
		func(arr);
	}
}

func([1, 2, 3]);
```

## Пример 3
Суммируем элементы массива. Здесь интереснее раскрывается суть рекурсии. Что-то вроде погружения и всплытия.

```js ln=true
function getSum(arr, sum) {
	sum += arr.shift();

	if (arr.length != 0) {
		sum = getSum(arr, sum);
	}

	return sum;
}

console.log(getSum([1, 2, 3], 0));
```

Мы берем массив, и значение суммы, равное изначально нулю, к сумме прибавляем первый элемент массива (сам элемент при этом удаляется). Далее смотрим, если в массиве еще есть элементы (его дина не равна нулю), значит, вызываем функцию заново, передавая остаток массива и текущую сумму. И так далее, пока не закончатся элементы массива. Когда они закончатся, то функция выйдет из рекурсии и вернет финальное значение суммы.

## Настоящий пример 1
Обходим произвольного уровня вложенности многомерный массив. К каждому элементу, если он не подмассив (конечный элемент), добавим к нему восклицательный знак.

Суть в том, что мы циклом проходим по элементам переданного массива и смотрим, конченый это элемент или нет. Если элемент конечный, то добавляем восклицательный знак, если элемент не конечный, а подмассив (смотрим его тип через `typeof`, массив будет иметь тип `object`), то запускаем заново функцию и передаем в неё этот подмассив. И так до конца, пока не будут перебраны абсолютно все конечные элементы начального массива и все его элементы-подмассивы

Например, есть массив `[1, [2, 3, 4], [5, 6, [7, 8]]]`

```js ln=true
function func(arr) {
	for (let i = 0; i < arr.length; i++) {
		if (typeof arr[i] == 'object') { // смотрим какого типа
			arr[i] = func(arr[i]);
		} else {
			arr[i] = arr[i] + '!';
		}
	}
	
	return arr;
}

console.log(func([1, [2, 3, 4], [5, 6, [7, 8]]]));
```

## Настоящий пример 2
На серверном варианте JS бывает задача пройтись по папкам любого уровня вложенности, найти вс файлы и что-то с ними сделать. Принцип тот же, что и в прошлом примере. Проходим рекурсией по структуре папок и смотрим, если это файл -- делаем что нужно, если папка, то передаем ее опять в функцию и смотрим структуру и так далее пока не переберутся все файлы во всех папках.

## Настоящий пример 3
Сложить цифры числа. 127 => 1+2+7=10 => 1+0 = 1

```js ln=true
function reduceNum(num) {
	var sum = getDigitsSum(num);

	if (sum >= 10) {
		return reduceNum(sum)
	} else {
		return suml;
	}
}

function getSum(arr) {
	let sum = 0;

	for (value of arr) {
		sum += +value;
	}

	return sum;
}

function getDigits(num) {
	return String(num).split('');
}

function getDigitsSum(num) {
	return getSum(getDigits(num));
}

console.log(reduceNum(99));
```

На пятой строчке мы смотрим, после суммирования цифр больше ли десяти полученная сумма. Если да, значит, надо пойти на второй круг, функция вернет запуск этой же функции с переданной суммой.

Нуужно обязательно передать результат работы фукнкции наружу, иначе ничего не получится.

## ХОРОШИЙ ПРИМЕР!!!

Задача из Каты
Нужна функция, которая проходит по всем элементам переданного объекта, в том числе вложенным, любой глубины вложенности и подсчитывает количество элементов с типом *строка*.

```js ln=true
function getStringCount(object, counter = 0) {

  for (let key in object) {
    if (typeof object[key] === 'object' && object[key] !== null) {
      counter = getStringCount(object[key], counter);
    } else if (typeof object[key] === 'string') {
      counter++;
    }
  }

  return counter;
}
```

Функция, собственно, и будет возвращать подсчитанное количество строк. В том числе самой себе в рекурсии, чтобы сохранить состояние счетчика внутри вложенных объектов/массивов.
- В объявлении функции инициализируем переменную счетчика нулём, она будет находиться в контексте вызова самого внешнего слоя рекурсии. Она же в конце вернется из функции, обновлённая последующими итерациями проверок.
- На строке `3` начинаем перебирать элементы переданного объекта
- На строке `4` смотрим, если элемент -- вложенный объект, то вызываем рекурсию для вложенного элемента, считаем строки внутри него.
- Если текущий элемент -- строка (строка в коде `6`), то инкрементируем счетчик на строке `7`
- После того как прошлись по всем вложенным элементам текущего элемента (с рекурсией, если есть вложенность еще глубже), возвращаем состояние счетчика наружу, на уровень рекурсии выше и присваиваем (обновляем значение) его переменной счетчика из контекста уровня выше.
- Так повторяем, пока не пройдемся по абсолютно всем элементам и вложенностям. В итоге на самый верхний уровень вернется обновленная переменная счетчика, которую и возвращаем в финале.