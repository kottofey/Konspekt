Строки. Строки в JavaScript кодируются в UTF-16. В JS нет отдельного типа для символа, как в других ЯП. Строки нужно оборачивать в кавычки: одинарные или двойные. Разницы в кавычках особой нет. Суть в том, что если строка обёрнута в один тип кавычек, то второй не нужно экранировать внутри первых. 
```JS
const String1 = `String`;
const String2 = 'String';
const String3 = "String";
```

\`Обратные кавычки\` имеют расширенную функциональность. Они позволяют нам встраивать выражения в строку, заключая их в `${…}`. Выражение внутри `${…}` вычисляется, и его результат становится частью строки. Мы можем положить туда всё что угодно: переменную `name`, или выражение `1 + 2`, или что-то более сложное. Например:
```javascript
let name = "Иван";

// Вставим переменную
alert( `Привет, ${name}!` ); // Привет, Иван!

// Вставим выражение
alert( `результат: ${1 + 2}` ); // результат: 3
```

Также, содержимое обратных кавычек может занимать более одной строки:
```js
let guestList = `Guests:
 * John
 * Pete
 * Mary
`;

alert(guestList); // список гостей, состоящий из нескольких строк
```

Строки неизменяемы! Когда строка объявлена и ей присвоено значение оно останется таким навсегда. Изменить его не выйдет. Но можно перезаписать содержимое переменной, изменив нужным образом.
## Конкатенация
Строки можно склеивать через знак `+` или через метод `.concat()`

## Свойства

Свойства появляются из-за того, что JS создает временный объект со значением этой строки и с набором методов и свойств, принадлежащих этой строке.

- `.length` - длина строки, можно обратиться к символу строки, в виде массива.
```js
const str = "Hello, World!";
str[str.length - 1]; // Выведет !, как последний символ
```

## Методы
- `.toUpperCase()` / `.toLowerCase()` - возвращает модифицированную в верхний или в нижний регистр строку
- `.concat(val1, val2, )` - конкатенация, аналог плюса
- `.indexOf(value, startIndex)` - возвращает первое вхождение первого аргумента. Второй необязательный аргумент указывает стартовую позицию с которой начинать искать. Если ничего не найдено вернёт `-1`. Если будет проверка в `if` и позиция окажется на первом месте (с нулевым индексом), то метод вернёт ноль и иф решит, что это false и ничего не сделает. Нужно проверять, что позиция не равна -1.
- `.lastIndexOf()` - То же, что и `.indexOf()`, но ищет с конца строки
- `.includes(value, startIndex)` - возвращает булево значение, если строка содержит указанный аргумент или нет. Регистрочувствительный метод.
- `.startsWith` / `.endsWith` - возвращает булево значение, если строка начинается или заканчивается на указанный аргумент или нет. Регистрочувствительный метод.
- `.slice(startIndex, endIndex)` - вырезает часть строки от и до указанных индексов, последний индекс не учитывается. Можно указать вторым аргументом отрицательное число, тогда конец будет считаться с конца строки. Второй аргумент необязателен и если не указан, то идём до конца строки.
- `.substring(startIndex, endIndex)` - то же, что и slice, но можно указать начало больше конца. Будет работать по принципу модуля значения, то есть, значения начала и конца поменяются местами. Отрицательные значения не поддерживаются и превращаются в ноль.
- `.substr(startIndex, length)` - возвращает подстроку начиная с указанного индекса и указанной длиной.
- `.replace(value, replaceWith)` - замена части строки на указанные значения
- `.at(value)` - возвращает символ на указанной позиции. Допускает отрицательные значения, тогда позиция считается с конца строки. `.at(-1)` вернёт последний символ строки.
- `.codePointAt(pos)` - возвращает код символа, находящегося в указанной в аргументе позиции
- `String.fromCodePoint(code)` - возвращает символ по его коду
- `str1.localeCompare(str2)` - сравнивает две строки с учетом правил локали. По умолчанию берется системный язык. Есть два необязательных аргумента, первый указывает язык, второй позволяет определить дополнительные правила, например, нужно ли учитывать различия между `"a"` и `"á"`
- `.trim()` - убирает пробелы в начале и конце строки
- `.repeat(n)` - повторяет строку n раз

## Сравнение строк
Строки сравниваются посимвольно в алфавитном порядке, но есть нюансы:
- строчные буквы больше заглавных
- диакритические знаки имеют больший вес

Сделаем строку, содержащую символы с кодами от `65` до `220` — это латиница и ещё некоторые распространённые символы:

```javascript
let str = '';

for (let i = 65; i <= 220; i++) {
  str += String.fromCodePoint(i);
}
alert( str );
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³`µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ
```

Как видно, сначала идут заглавные буквы, затем несколько спецсимволов, затем строчные и `Ö` ближе к концу вывода.

Теперь очевидно, почему `a > Z`.

Символы сравниваются по их кодам. Больший код — больший символ. Код `a` (97) больше кода `Z` (90).

- Все строчные буквы идут после заглавных, так как их коды больше.
- Некоторые буквы, такие как `Ö`, вообще находятся вне основного алфавита. У этой буквы код больше, чем у любой буквы от `a` до `z`.

Все современные браузеры (для IE10 нужна дополнительная библиотека [Intl.JS](https://github.com/andyearnshaw/Intl.js/)) поддерживают стандарт [ECMA 402](https://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf), обеспечивающий правильное сравнение строк на разных языках с учётом их правил.

Для этого есть соответствующий метод.

Вызов [str.localeCompare(str2)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare) возвращает число, которое показывает, какая строка больше в соответствии с правилами языка:

- Отрицательное число, если `str` меньше `str2`.
- Положительное число, если `str` больше `str2`.
- `0`, если строки равны.

Например:
```javascript
alert( 'Österreich'.localeCompare('Zealand') ); // -1
```

У этого метода есть два дополнительных аргумента, которые указаны в [документации](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare). Первый позволяет указать язык (по умолчанию берётся из окружения) — от него зависит порядок букв. Второй — определить дополнительные правила, такие как чувствительность к регистру, а также следует ли учитывать различия между `"a"` и `"á"`.

## Template String
Или Шаблонные Строки. Нужны чтобы в строку добавлять какие-то переменные или другой код. Для этого оборачиваем строку в обратные кавычки. Код и\или переменные нужно завернуть в конструкцию `${ваш_код_здесь}`. Всё внутри фигурных скобок выполнится и вся эта конструкция заменится на результат выполнения кода.

Пример оборачивания многострочной строки в тег `<p>` (из задачи Ката)

```js
function wrapInParagraph(str){
  return `<p>${str.split('\n').join('</p>\n<p>')}</p>`;
}

// на входе:
// `Some
// simple multiline
// text`;

// На выходе: 
// <p>Some</p>
// <p>simple multiline</p>
// <p>text</p>
```

Пример создания списка и внедрения его в body страницы:

```js
const firstName = 'Roman';
const lastName = 'Lavrov';
const age = 30;

let str;

// как было до ES6
str = '<ul>' +
		'<li>First Name: ' + firstName + '</li>' +
		'<li>Last Name: ' + lastName + '</li>' +
		'<li>Age: ' + agee + '</li>' +
		'</ul>';

// как стало с ES6
str = `
	<ul>
		<li>First Name: ${ firstName }</li>
		<li>Last Name: ${ lastName }</li>
		<li>Age: ${ age }</li>
	</ul>
`;

document.body.innerHTML = str;
```