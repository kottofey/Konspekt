```table-of-contents
```
# Типы свойств объекта 
```js
const user = {
	firstName: 'Roman',
	age: 30,
	isAdmin: true,
	email: 'email@server.com',
	'user-address': {
		city: 'Moscow',
		street: 'StrretName'
	},
	skills: ['html', 'css', 'js'],
}
```

Объект состоит из `свойств`, которые представляют собой пары ключей и значений. Значения могут быть любым другим типом данных, например, другие вложенные объекты, [[массивы]] и т д.

Ключи должны оборачиваться кавычками, если состоят из чего-то большего, чем просто набор букв. Например, если ключ включает в себя дефис. Без кавычек он будет восприниматься, как знак вычитания. Ключи это всегда строки. Или символы ([[_Symbol|тип данных Symbol]])

Свойства бывают двух типов:
- Свойства-данные
- Свойства-аксессоры
По своей сути аксессоры - это функции, которые используются для присвоения и получения значения, но во внешнем коде они выглядят как обычные свойства объекта.

Свойства-аксессоры представлены методами: «геттер» – для чтения и «сеттер» – для записи.
## Геттеры и сеттеры
Это поля (не совсем обычные) в объекте.

Например, есть объект, описывающий человека. В нём есть свойства год рождения и возраст. В поле год рождения, собственно, указан год рождения. А для поля возраст реализованы геттер и сеттер. Они вступают в работу, когда идёт обращение в указанному полю. Это не обязательно будет возвращение из геттера значения поля, это может быть любая логика, которую мы захотим. Например:

```js ln=true
const person = {
	birthYear: 1993,
		age: {
			get: {
				return "Hello!!!";
			}
			set(value): {
				console.log("Set age: ", this.age);
			}
	}
}

person.age; // Hello!!!
person.age = 100; 
person.age; // Hello!!!
```

Здесь на строке `13` мы обращаемся к полю `age`. И в соответствии с геттером получаем не значение поля, а строку `Hello!!!`. А на строке `14` и `15` обращаемся к сеттеру поля `age` и передаем сеттеру значение 100. Он послушно выведет строку `Set age: 100`, однако не поменяет значение поля age. Ибо этого нет в сеттере.
## Дескрипторы свойств данных

Помимо значения `value` и `name`, свойства объекта имеют три специальных атрибута (так называемые «флаги»).

- **`writable`** – если `true`, свойство можно изменить, иначе оно только для чтения.
- **`enumerable`** – если `true`, свойство перечисляется в циклах, в противном случае циклы его игнорируют.
- **`configurable`** – если `true`, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя.

Метод [Object.getOwnPropertyDescriptor](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor) позволяет получить _полную_ информацию о свойстве.

Его синтаксис:

```javascript
let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
```

- `obj` - Объект, из которого мы получаем информацию.
- `propertyName` - Имя свойства.

Возвращаемое значение – это объект, так называемый «дескриптор свойства»: он содержит значение свойства и все его флаги.

Например:

```javascript
let user = {
  name: "John"
};

let descriptor = Object.getOwnPropertyDescriptor(user, 'name');

alert( JSON.stringify(descriptor, null, 2 ) );
/* дескриптор свойства:
{
  "value": "John",
  "writable": true,
  "enumerable": true,
  "configurable": true
}
*/
```

Чтобы изменить флаги, мы можем использовать метод [Object.defineProperty](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).

Его синтаксис:

```javascript
Object.defineProperty(obj, propertyName, descriptor)
```

`obj`, `propertyName` - Объект и его свойство, для которого нужно применить дескриптор.

`descriptor` - Применяемый дескриптор.

Если свойство существует, `defineProperty` обновит его флаги. В противном случае метод создаёт новое свойство с указанным значением и флагами; если какой-либо флаг не указан явно, ему присваивается значение `false`.

Например, здесь создаётся свойство `name`, все флаги которого имеют значение `false`:

```javascript
let user = {};

Object.defineProperty(user, "name", {
  value: "John"
});

let descriptor = Object.getOwnPropertyDescriptor(user, 'name');

alert( JSON.stringify(descriptor, null, 2 ) );
/*
{
  "value": "John",
  "writable": false,
  "enumerable": false,
  "configurable": false
}
 */
```

Сравните это с предыдущим примером, в котором мы создали свойство `user.name` «обычным способом»: в этот раз все флаги имеют значение `false`. Если это не то, что нам нужно, надо присвоить им значения `true` в параметре `descriptor`.

### Только для чтения (writable: false)

Сделаем свойство `user.name` доступным только для чтения. Для этого изменим флаг `writable`:

```javascript
let user = {
  name: "John"
};

Object.defineProperty(user, "name", {
  writable: false
});

user.name = "Pete"; // Ошибка: Невозможно изменить доступное только для чтения свойство 'name'
```

Теперь никто не сможет изменить имя пользователя, если только не обновит соответствующий флаг новым вызовом `defineProperty`.

Ошибки появляются только в строгом режиме

В нестрогом режиме, без `use strict`, мы не увидим никаких ошибок при записи в свойства «только для чтения» и т.п. Но эти операции всё равно не будут выполнены успешно. Действия, нарушающие ограничения флагов, в нестрогом режиме просто молча игнорируются.

Вот тот же пример, но свойство создано «с нуля»:

```javascript
let user = { };

Object.defineProperty(user, "name", {
  value: "John",
  // для нового свойства необходимо явно указывать все флаги, для которых значение true
  enumerable: true,
  configurable: true
});

alert(user.name); // John
user.name = "Pete"; // Ошибка
```

### Неперечислимое свойство (enumerable: false)

Добавим собственный метод `toString` к объекту `user`.

Встроенный метод `toString` в объектах – неперечислимый, его не видно в цикле `for..in`. Но если мы напишем свой собственный метод `toString`, цикл `for..in` будет выводить его по умолчанию:

```javascript
let user = {
  name: "John",
  toString() {
    return this.name;
  }
};

// По умолчанию оба свойства выведутся:
for (let key in user) alert(key); // name, toString
```

Если мы этого не хотим, можно установить для свойства `enumerable:false`. Тогда оно перестанет появляться в цикле `for..in` аналогично встроенному `toString`:

```javascript
let user = {
  name: "John",
  toString() {
    return this.name;
  }
};

Object.defineProperty(user, "toString", {
  enumerable: false
});

// Теперь наше свойство toString пропало из цикла:
for (let key in user) alert(key); // name
```

Неперечислимые свойства также не возвращаются `Object.keys`:

```javascript
alert(Object.keys(user)); // name
```

### Неконфигурируемое свойство (configurable: false)

Флаг неконфигурируемого свойства (`configurable:false`) иногда предустановлен для некоторых встроенных объектов и свойств.

Неконфигурируемое свойство не может быть удалено, его атрибуты не могут быть изменены.

Например, свойство `Math.PI` – только для чтения, неперечислимое и неконфигурируемое:

```javascript
let descriptor = Object.getOwnPropertyDescriptor(Math, 'PI');

alert( JSON.stringify(descriptor, null, 2 ) );
/*
{
  "value": 3.141592653589793,
  "writable": false,
  "enumerable": false,
  "configurable": false
}
*/
```

То есть программист не сможет изменить значение `Math.PI` или перезаписать его.

```javascript
Math.PI = 3; // Ошибка, потому что writable: false

// delete Math.PI тоже не сработает
```

Мы также не можем изменить `writable`:

```javascript
// Ошибка, из-за configurable: false
Object.defineProperty(Math, "PI", { writable: true });
```

Мы абсолютно ничего не можем сделать с `Math.PI`.

Определение свойства как неконфигурируемого – это дорога в один конец. Мы не можем изменить его обратно с помощью `defineProperty`.

**Обратите внимание: `configurable: false` не даст изменить флаги свойства, а также не даст его удалить. При этом можно изменить значение свойства.**

В коде ниже свойство `user.name` является неконфигурируемым, но мы все ещё можем изменить его значение (т.к. `writable: true`).

```javascript
let user = {
  name: "John"
};

Object.defineProperty(user, "name", {
  configurable: false
});

user.name = "Pete"; // работает
delete user.name; // Ошибка
```

А здесь мы делаем `user.name` «навечно запечатанной» константой, как и встроенный `Math.PI`:

```javascript
let user = {
  name: "John"
};

Object.defineProperty(user, "name", {
  writable: false,
  configurable: false
});

// теперь невозможно изменить user.name или его флаги
// всё это не будет работать:
user.name = "Pete";
delete user.name;
Object.defineProperty(user, "name", { value: "Pete" });
```
## Дескрипторы свойств доступа
Дескрипторы свойств-аксессоров отличаются от «обычных» свойств-данных.

Свойства-аксессоры не имеют `value` и `writable`, но взамен предлагают функции `get` и `set`.

То есть, дескриптор аксессора может иметь:

- **`get`** – функция без аргументов, которая сработает при чтении свойства,
- **`set`** – функция, принимающая один аргумент, вызываемая при присвоении свойства,
- **`enumerable`** – то же самое, что и для свойств-данных,
- **`configurable`** – то же самое, что и для свойств-данных.

Например, для создания аксессора `fullName` при помощи `defineProperty` мы можем передать дескриптор с использованием `get` и `set`:

```javascript
let user = {
  name: "John",
  surname: "Smith"
};

Object.defineProperty(user, 'fullName', {
  get() {
    return `${this.name} ${this.surname}`;
  },

  set(value) {
    [this.name, this.surname] = value.split(" ");
  }
});

alert(user.fullName); // John Smith

for(let key in user) alert(key); // name, surname
```

Ещё раз заметим, что свойство объекта может быть либо свойством-аксессором (с методами `get/set`), либо свойством-данным (со значением `value`).

При попытке указать и `get`, и `value` в одном дескрипторе будет ошибка:

```javascript
// Error: Invalid property descriptor.
Object.defineProperty({}, 'prop', {
  get() {
    return 1
  },

  value: 2
});
```
# Метод Object.defineProperties()

![[Object.defineProperties()]]

# Метод Object.getOwnPropertyDescriptors()

![[Object.getOwnPropertyDescriptors()]]

# Глобальное запечатывание объекта

Дескрипторы свойств работают на уровне конкретных свойств.

Но ещё есть методы, которые ограничивают доступ ко _всему_ объекту:

![[Object.preventExtensions()]]

Запрещает добавлять новые свойства в объект.

![[Object.seal()]]

Запрещает добавлять/удалять свойства. Устанавливает `configurable: false` для всех существующих свойств.

![[Object.freeze()]]

Запрещает добавлять/удалять/изменять свойства. Устанавливает `configurable: false, writable: false` для всех существующих свойств.

А также есть методы для их проверки:

![[Object.isExtensible()]]

Возвращает `false`, если добавление свойств запрещено, иначе `true`.

![[Object.isSealed()]]
Возвращает `true`, если добавление/удаление свойств запрещено и для всех существующих свойств установлено `configurable: false`.

![[Object.isFrozen()]]

Возвращает `true`, если добавление/удаление/изменение свойств запрещено, и для всех текущих свойств установлено `configurable: false, writable: false`.

На практике эти методы используют редко.
# Доступ к свойствам объекта

Можно полчить доступ либо через точку: `user.firstName`
Либо через квадратные скобки: `user['isAdmin']`, `user['user-address']`
> Доступ к сложным ключам можно получить только через квадратные скобки.

Чтобы получить доступ ко вложенным свойствам, можно продолжить цепочку:
- `user['user-address'].city`
- `user['user-address'].['city']`
- `user['skills'][0]` - выдаст 'html'

- `user['user-address'].[city]` - даст ошибку, интерпретатор посчитает `city` за переменную и пожалуется, что она не определена

# Изменение свойств
`user.firstName = 'OtherName'`

Если присвоить объекту поле, которого в нём нет, такое поле создастся.

Если попытаться записать или обратиться к свойству свойства, которого не существует, то будет ошибка.

```js
const obj = {
	key1: {
	subkey1: value
	},
}

obj.key2.subkey2 = 'smth'; // ОШИБКА!
```

Мы создаем свойство `key2`, которое будет иметь значение `undefined`, а у `undefined` невозможно создать свои свойства. Нужно сначала инициализировать внутренний объект, хотя бы пустым объектом `{}` и тогда у него можно будет создавать свойства.

# Другие типы объектов
Подтипами объектов являются также:
- [[Массивы]]
- Функции
- Даты `new Date()`
# Конструкторы
Конструктор это функция, которая, будучи вызвана с ключевым словом `new` возвращает вновь созданный объект. 

Конструкторы принято называть с большой буквы, чтобы как-то отличать их от обычных функций:

```js ln=true
let Person, person, anotherPerson;

Person = function(name) {
	this.name = name;
};

person = new Person('Roman');
anotherPerson = new Person('Nata');
console.log(person.name); // Roman
console.log(anotherPerson.name); // Nata

Person.prototype.greet = function () {
	console.log('Hello, my name is ' + this.name);
};

person.greet(); // Hello, my name is Roman
anotherPerson.greet(); // Hello, my name is Nata
```

Здесь конструктор принимает значение имени и записывает это свойство в объект. `(4)`

На строке `(12)` мы определяем свойство-метод `greet()` для прототипа объектов `Person`, которая выводит имя в консоль. Этот метод будет доступен всем созданным на основе этого прототипа объектам `(16)`, `(17)`.

Каждому объекту автоматически создается скрытое свойство `constructor`, которое вызывается при создании объекта.

Когда вызывается конструктор, то происходит следующее:
- Создаётся новый пустой объект, и он присваивается `this`.
- Выполняется тело функции. Обычно оно модифицирует `this`, добавляя туда новые свойства.
- Возвращается значение `this`.

## new function() { … }
Если в нашем коде присутствует большое количество строк, создающих один сложный объект, то мы можем обернуть их в функцию-конструктор, которая будет немедленно вызвана, вот так:

```javascript
// создаём функцию и сразу же вызываем её с помощью new
let user = new function() {
  this.name = "John";
  this.isAdmin = false;

  // ...другой код для создания пользователя
  // возможна любая сложная логика и инструкции
  // локальные переменные и так далее
};
```

Такой конструктор не может быть вызван снова, так как он нигде не сохраняется, просто создаётся и тут же вызывается. Таким образом, этот трюк направлен на инкапсуляцию кода, который создаёт отдельный объект, без возможности повторного использования в будущем.

## Создание методов в конструкторе

Использование конструкторов для создания объектов даёт большую гибкость. Функции-конструкторы могут иметь параметры, определяющие, как создавать объект и что в него записывать.

Конечно, мы можем добавить к `this` не только свойства, но и методы.

Например, `new User(name)` ниже создаёт объект с заданным `name` и методом `sayHi`:

```javascript
function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert( "Меня зовут: " + this.name );
  };
}

let john = new User("John");

john.sayHi(); // Меня зовут: John

/*
john = {
   name: "John",
   sayHi: function() { ... }
}
*/
```
# Использование оператора `new`
```js
// Все функции-конструкторы, созданные с помощью 'new', будут иметь тип 'object'
var str = new String("String");
var num = new Number(100);

typeof str; // Вернёт 'object'
typeof num; // Вернёт 'object'

// Но существует исключение для конструктора Function

var func = new Function();

typeof func; // Вернёт 'function'
```

# Методы и функции
![[hasOwnProperty(prop)]]

![[Object.is()]]

# Простейший объект, словари
Как мы знаем, объекты можно использовать как ассоциативные массивы для хранения пар ключ/значение.

…Но если мы попробуем хранить _созданные пользователями_ ключи (например, словари с пользовательским вводом), мы можем заметить интересный сбой: все ключи работают как ожидается, за исключением `"__proto__"`.

Посмотрите на пример:

```javascript
let obj = {};

let key = prompt("What's the key?", "__proto__");
obj[key] = "some value";

alert(obj[key]); // [object Object], не "some value"!
```

Если пользователь введёт `__proto__`, присвоение проигнорируется!

И это не должно удивлять нас. Свойство `__proto__` особенное: оно должно быть либо объектом, либо `null`, а строка не может стать прототипом.

Но мы не _намеревались_ реализовывать такое поведение, не так ли? Мы хотим хранить пары ключ/значение, и ключ с именем `"__proto__"` не был сохранён надлежащим образом. Так что это ошибка!

Конкретно в этом примере последствия не так ужасны, но если мы присваиваем объектные значения, то прототип и в самом деле может быть изменён. В результате дальнейшее выполнение пойдёт совершенно непредсказуемым образом.

Что хуже всего – разработчики не задумываются о такой возможности совсем. Это делает такие ошибки сложным для отлавливания или даже превращает их в уязвимости, особенно когда JavaScript используется на сервере.

Неожиданные вещи могут случаться также при присвоении свойства `toString`, которое по умолчанию функция, и других свойств, которые тоже на самом деле являются встроенными методами.

Как же избежать проблемы?

Во-первых, мы можем переключиться на использование коллекции `Map`, и тогда всё будет в порядке.

Но и `Object` может также хорошо подойти, потому что создатели языка уже давно продумали решение проблемы.

Свойство `__proto__` – не обычное, а аксессор, заданный в `Object.prototype`:

![[Pasted image 20240720205552.png]]

Так что при чтении или установке `obj.__proto__` вызывается соответствующий геттер/сеттер из прототипа `obj`, и именно он устанавливает/получает свойство `[[Prototype]]`.

Как было сказано в начале этой секции учебника, `__proto__` – это способ доступа к свойству `[[Prototype]]`, это не само свойство `[[Prototype]]`.

Теперь, если мы хотим использовать объект как ассоциативный массив, мы можем сделать это с помощью небольшого трюка:

```javascript
let obj = Object.create(null);

let key = prompt("What's the key?", "__proto__");
obj[key] = "some value";

alert(obj[key]); // "some value"
```

`Object.create(null)` создаёт пустой объект без прототипа (`[[Prototype]]` будет `null`):

![[Pasted image 20240720205626.png]]

Таким образом не будет унаследованного геттера/сеттера для `__proto__`. Теперь это свойство обрабатывается как обычное свойство, и приведённый выше пример работает правильно.

Мы можем назвать такой объект «простейшим» или «чистым словарным объектом», потому что он ещё проще, чем обычные объекты `{...}`.

Недостаток в том, что у таких объектов не будет встроенных методов объекта, таких как `toString`:

```javascript
let obj = Object.create(null);

alert(obj); // Ошибка (no toString)
```

…Но обычно это нормально для ассоциативных массивов.

Обратите внимание, что большинство методов, связанных с объектами, имеют вид `Object.something(...)`. К примеру, `Object.keys(obj)`. Подобные методы не находятся в прототипе, так что они продолжат работать для таких объектов:

```javascript
let chineseDictionary = Object.create(null);
chineseDictionary.hello = "你好";
chineseDictionary.bye = "再见";

alert(Object.keys(chineseDictionary)); // hello,bye
```

