Оператор `...` является и спрэдом, и рестом. Всё зависит от области его применения.
# Spread

Как `spread` он разворачивает массивы или объекты и служит для создания новых массивов или объектов. Или служит для их трансформации в более удобные типы данных.
## Spread с массивами
Например, есть массив с городами. Спрэд его из массива развернет в последовательность значений.
```js
const cities = ['Moscow', 'SPb', 'Rostov'];

cosole.log(...cities); // Moscow SPb Rostov
```

Это можно использовать, чтобы заливать массивы друг в друга. Можно также вставлять элементы между спрэдами

```js
const a = [1, 2, 3];
const b = [4, 5, 6];

const c = [...a, ...b]; // [1, 2, 3, 4, 5, 6]
const d = [...a, 3.5, ...b]; // [1, 2, 3, 3.5, 4, 5, 6]
```

Разворачивание массива может быть полезным, если нужно подставить аргумент не массив, а его значения. Например, для `Math.max(numbers)`. Если подсунуть аргументом просто `numbers`, то будет ошибка ибо метод `.max()` ожидает получить несколько значений, а не ссылку на массив. Поэтому надо передавать со спрэдом.

```js
const numbers = [1, 3, 29, 19, 42, -2];

Math.max(...numbers); // 42
Math.max(numbers); // ошибка
```

Спрэд можно использовать для превращения строки в массив из символов

```js
const str = 'Hello';

console.log(...str); // H e l l o
```

Другой пример. Например, в html есть несколько элементов, скажем, дивы

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Title</title>
</head>
	<body>
		<div></div>
		<div></div>
		<div></div>
		<div></div>
		<div></div>
	</body>
</html>
```

Нужно получить доступ ко всем нодам, как к элементам массива.

```js
const divs = querySelectorAll('div'); 
```

`divs` -- это коллекция DOM-элементов, некоторых методов массивов у неё нет ибо не определены в прототипе. Чтобы получить доступ к, например, методу `.map()`, нужно преобразовать эту коллекцию в массив через спрэд.

```js
const divs = querySelectorAll('div'); // divs это коллекция NodeList
const nodes = (...divs); // nodes это уже массив
```
## Spread с объектами

Чтобы использовать спрэд с объектами, нужно обернуть спред в фигурные скобки чтобы было куда складывать ключи и значения. Без фигурных скобок спред будет складывать элементы в массив по умолчанию.

```js
const obj = {
	a: 1,
	b: 2,
	c: 3
}

console.log({...obj}); // { a: 1, b: 2, c: 3 }
```

Если объединять объекты, то если существуют одинаковые ключи, то значения этих ключей заменятся на самое последнее значение.

```js
const obj1 = {
	a: 1,
	b: 2,
	c: 3
}

const obj2 = {
	a: 11,
	d: 22,
	e: 33
}

console.log({...obj1, ...obj2}); // { a: 11, b: 2, c: 3, d: 22, e: 33 }
console.log({...obj2, ...obj1}); // { a: 1, d: 22, e: 33, b: 2, c: 3 }
```

Еще один пример объединения свойств объектов:

```js
const merge = (obj1, ...rest) => {
	return Object.assign(obj1, ...rest);
};

console.log(
	merge(
		{
			name: 'John',
			age: 22,
		},
		{
			surname: 'Klein',
			age: 20,
			profession: 'student',
		},
		{
			profession: 'frontend developer',
			country: 'USA',
		}
	)
);

// { name: "John", age: 20, surname: "Klein", profession: "frontend developer", country: "USA" }
```
# Rest

Чтобы троеточие из спрэда превратилось в рэст нужно, чтобы он был не единственным аргументом в функции и шел последним аргументом. Иначе он превратится в спрэд.

Как `rest` он собирает оставшиеся неиспользованными параметры в массив (или объект)

```js
function sum(a, b) {
	return a + b;
}

const nums = [1, 2, 3, 4, 5];

console.log(sum(...nums)); // 3
// Здесь троеточие это спрэд!
```

В данном примере спрэд развернул массив и подставил первые два значения в функцию, потому что она больше не принимала.

Чтобы использовать все оставшиеся значения, нужно в описании аргументов функции использовать рэст!

```js ln=true
function sum(a, b, ...rest) {
	console.log(rest);
	return a + b + rest.reduce((accumulator, value) => accumulator + value, 0);
}

const nums = [1, 2, 3, 4, 5];

console.log(sum(...nums)); // 15
```

На строке `2` при переданном в строке `8` массиве результат будет `[3, 4, 5]`, потому что первые два значения подставились вместо первого и второго аргументов, а остальное рэст скомпоновал в остаточный массив. Который на строке `3` мы обрабатываем через `reduce`. Причём, после стрелочной функции вторым аргументом редьюса мы указываем начальное значение аккумулятора.

## Деструктуризация при помощи rest

Для массивов:
```js
const numbers = [1, 2, 3, 4, 5];

const [a, b, ...other] = numbers;
console.log(a, b, other); // 1, 2, [3, 4, 5]
```

Для объектов:
```js
const person = {
	name: 'Roman',
	age: 35,
	country: 'Russia', 
	city: 'SPb'
}

const {name, age, ...address} = person;

console.log(name, age, address); // Roman 35 {country: 'Russia', city: 'SPb'}
```

# Итого
## [Итого](https://learn.javascript.ru/rest-parameters-spread-operator#itogo)

Когда мы видим `...` в коде, это могут быть как остаточные параметры, так и оператор расширения.

Как отличить их друг от друга:

- Если `...` располагается в конце списка параметров функции, то это «остаточные параметры». Он собирает остальные неуказанные аргументы и делает из них массив.
- Если `...` встретился в вызове функции или где-либо ещё, то это «оператор расширения». Он извлекает элементы из массива.

Полезно запомнить:

- Остаточные параметры используются, чтобы создавать новые функции с неопределённым числом аргументов.
- С помощью оператора расширения можно вставить массив в функцию, которая по умолчанию работает с обычным списком аргументов.
