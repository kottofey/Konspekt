```table-of-contents
```

Это функции, которые передаются в другие функции в качестве аргумента.

## Синхронные коллбеки

```js ln=true
const arr = [1, 2, 3, 4];
const out1 = document.querySelector('#pre1');
const out2 = document.querySelector('#pre2');

function f1(arr, callback, block) {
  const result = arr.map(el => selfPower(el));
  callback(result, block);
}

function showArrStar(arr, block) {
  const result = [];
  arr.forEach(el => result.push(el));
  block.innerHTML = result.join('*');
}

function showArrDash(arr, block) {
  const result = [];
  arr.forEach(el => result.push(el));
  block.innerHTML = result.join('-');
}

function selfPower(a) {
  return a ** a;
}

showArrStar(arr, out1); // использование функции напрямую
f1(arr, showArrStar, out2); // Используем в качестве коллбэка
f1(arr, showArrDash, out3); // Используем в качестве коллбэка
```

На строке `26` мы вызываем функцию `showArrStar` напрямую и она послушно выводит содержимое переданного массива в указанный блок.

А на строке `27` мы передаём функцию `showArrStar` в качестве коллбэка. Заметьте, без круглых скобок, просто название! Если указать круглые скобки, то она сразу же исполнится и в аргумент ничего не попадёт. Точнее, попадёт то, что вернёт исполненная функция.

Как оно работает в случае с коллбеком (вызываем `f1` на строке `27`):
- Мы определяем на строках `5-8` функцию `f()`, которая преобразовывает переданный в неё массив и вызывает переданный в неё коллбек, в который, в свою очередь, передаются результат обработки массива и некий блок из разметки.
- На строках `10-14` мы определяем функцию, которую захотели использовать в качестве коллбека. Она выводит переданный в неё массив в указанный блок из разметки. В данном случае через звездочку.
- На строке `27` вызываем функцию `f1` и передаем в неё исходный массив, функцию-коллбек и блок куда нужно вывести результат. Функция-коллбек может быть, в принципе, любой функцией, главное, чтобы её реализация совпадала с тем, как организована работа в материнской функции, то есть, чтобы совпадали переданные параметры. В данном случае, в коллбек нужно передавать некий массив и некий блок куда нужно этот массив выводить. Это и реализовано на строке `7`
- Внутри `f1` мы преобразовываем переданный массив и запихиваем его в переменную `result`, а потом вызываем переданный коллбек и передаем в него результат и блок.
- То же самое происходит на строке `28`, но в качестве коллбека мы использовали `shawArrDash` и вывели результат в блок `out3`. И результат вывелся через тире, как и реализовано в коллбеке.

В качестве коллбеков можно использовать анонимные функции прямо в аргументах.

## Асинхронные коллбеки

Коллбеки, которые работают при асинхронных запросах принято называть асинхронными. Она ничем не отличается от синхронных коллбеков, просто работает рядом с асинхронными штуками.

```js ln=true
async function pageLoader(callback) {
	const data = await fetch('https://...');
	callback(data);
}

function getAJAX(data) {
	console.log("Послали запрос");
	console.log("Ответ сервера");
	console.log(data);
}

pageLoader(getAJAX);
```

Здесь асинхронность заключается в том, что ответ сервера может быть не в момент выполнения функции. Чтобы не поломать логику работы мы используем `await` чтобы дождаться ответа сервера и только потом вызываем коллбек.

Другой синтаксис:
```js ln=true
function pageLoader(callback) {
	fetch('https://...')
	.then(response => response.json())
	.then(json => callback(json));
}

function getAJAX(data) {
	console.log("Послали запрос");
	console.log("Ответ сервера");
	console.log(data);
}

pageLoader(getAJAX);
```

На строке `2` мы запрашиваем некую информацию, на строке `3` преобразовываем ее в json формат и на строке `4` передаем полученный json в коллбек. Результат будет такой же, что и в прошлом примере. И опять же, так как функция `fetch` асинхронная - то и коллбек внутри нее является асинхронным.

## Ад коллбеков

```js
function pageLoader() {
	fetch('https://...')
	.then(responce => responce.json())
	.then(json => {
		console.log("Послали запрос");
		console.log("Ответ сервера");
		console.log(json);
	});
}

pageLoader();
```

Мы сделали запрос к сайту, получили какой-то ответ и вывели его в консоль. А что если нам надо с ответом что-то сделать дальше, например, вытащить инфу по `userId` из полученного в ответе json. Например, из полученного json вытащить что-то дальше. Так как ответ мы получили внутри `fetch` и мы хотим что-то делать с этим ответом (а он не будет виден снаружи фетча - область видимости и всё такое), то дальнейший запрос к серверу нужно делать внутри первого фетча:

```js
function pageLoader() {
	fetch('https://...')
		.then(responce => responce.json())
		.then(json => {
			console.log("Послали запрос");
			console.log("Ответ сервера");
			console.log(json);

			fetch('https://новый запрос/' + json.userId)
				.then(response => response.json())
				.then(json => {
					console.log("Послали запрос");
					console.log("Ответ сервера");
					console.log(json);
				});
	});
}

pageLoader();
```

Если продолжать эту пирамиду далее, то она будет разрастаться дальше и дальше, до тех пор пока уследить, что вообще происходит, будет очень сложно, если вообще возможно. Такая вложенность называется ***Адом коллбеков***. Пирамида будет разрастаться вправо. Избежать этого ада можно следующим образом. 

Как один из вариантов можно написать несколько последовательных функций, которые будут делать что-то и вызывать следующий коллбек по завершению своей части работы. таким образом пирамида исчезнет, но будет создано несколько "одноразовых" функций, которые нигде больше не будут использоваться. 

```js ln=true
function pageLoader(url, callback) {
	fetch(url)
		.then(response => response.json())
		.then(json => callback(json))
}

function getAJAX(data) {
	console.log("Послали запрос");
	console.log("Ответ сервера");
	console.log(data);
	pageLoader('https://новый запрос/' + data.userId, showUser)
}

function showUser(user) {
	console.log(user);
}

pageLoader('https://...', getAJAX);
```

Тут мы вызываем `pageLoader` на строке `18`, в качестве коллбека указываем функцию первого шага `getAJAX`. Она отрабатывает, получает ответ от сервера. Внутри неё мы запускаем второй шаг - заново посылаем запрос на сервер через `pageLoader`, но на этот раз указываем коллбеком `showUser`, который и выведет нам результат, полученный от сервера.

Способ неплох, но не избавляет полностью от ада коллбеков, он просто реорганизовывает код и убирает вложенность, код легче читается. Но есть способы и лучше! И это [[28. Промисы|промисы]]. 

## Перехват ошибок

А что если коллбек не отработал штатно. Например, сайт не отдал ответ на запрос. Для этого надо немного апгрейдить функцию коллбека. Существуют два события `.onload` и `.onerror`. Первое выстреливает когда скрипт успешно загружен, второе -- при ошибке. 

```javascript
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`Не удалось загрузить скрипт ${src}`));

  document.head.append(script);
}
```

Здесь мы загружаем некий скрипт и добавляем его на страничку в секцию `<head>`. В коллбек передаем два аргумента. Первый -- ошибку, вторым (и последующими, если необходимо) параметром -- скрипт. При успешной загрузке скрипта вместо ошибки передаём `null`, так как ошибки нет, и сам скрипт. В случае ошибки выкидываем объект ошибки.

Пример использвания:

```javascript
loadScript('/my/script.js', function(error, script) {
  if (error) {
    // обрабатываем ошибку
  } else {
    // скрипт успешно загружен
  }
});
```

Такой подход называется «коллбэк с первым аргументом-ошибкой» («error-first callback»).

Правила таковы:

1. Первый аргумент функции `callback` зарезервирован для ошибки. В этом случае вызов выглядит вот так: `callback(err)`.
2. Второй и последующие аргументы — для результатов выполнения. В этом случае вызов выглядит вот так: `callback(null, result1, result2…)`.

Одна и та же функция `callback` используется и для информирования об ошибке, и для передачи результатов.

## Задача из Каты

```js
function getFileSize(filename, cb) {...};

function sumFileSizes(filename1, filename2, cb) {
	getFileSize(filename1, res1 => {
		getFileSize(filename2, res2 => cb(res1 + res2))
})

}
```

Функция `getFileSize` имитирует асинхронность и возвращает размер файла для коллбека, указанного вторым её параметром. 

В `sumFileSizes` мы передаем имена файлов и финальный коллбек, который нужно вызвать и передать в него сумму размеров файлов. Мы вызываем первый `getFileSize` с именем первого файла, вторым параметром пишем собственный коллбек параметром которого будет размер файла, возвращенный из `getFileSize`. в теле второго коллбека заново вызываем `getFileSize` с именем второго файла и вторым параметром вызываем финальный коллбек куда передаём сумму размеров файлов. Как-то так... 