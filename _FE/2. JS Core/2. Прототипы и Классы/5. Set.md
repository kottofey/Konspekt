```table-of-contents
```

Это множество! Реализация в JS отличается от других ЯП, но главная особенность осталась -- уникальность значений. Значениями может быть что угодно.

Отличием от других ЯП является отсутствие методов `.union()`, `.difference()` `.intersection()`. Их можно добавить, но это нетривиальная задачка.

Использовать множество нужно в том случае, когда уникальность имеет значение. Например, когда храним css классы DOM элемента, потому что не должно быть двух одинаковых классов для одного элемента. Если для хранения использовать массив, то при добавлении нужно будет проверить наличие элемента, а в множестве просто добавляем через `.add()` и не паримся об уникальности.

Множество запоминает порядок элементов, добавленных в него. Поменять этот порядок напрямую невозможно, хотя, можно удалить значения и добавить их в нужном порядке. 



```js
const set = new Set(['button', 'active', 'small']);

console.log(set); // button, active, small

const set1 = new Set('button');
console.log(set1); // b, u, t, o, n
// буква t один раз, т.к. значения только уникальные!
```

Чтобы создать множество из одного элемента, нужно передать в него массив из одного элемента.

Множества можно клонировать передав при создании другое множество в качестве аргумента.

Если при создании множества передать не итерируемый аргумент, то выскочит ошибка. Например:

```js
const set = new Set(42); // ошибка!
```

Всё потому, что при создании множества конструктор пытается вызвать метод для получения перебираемого объекта. У числа (в том числе) нет такого метода и потому вылетает ошибка.

# Получение доступа к элементам множества

Во множествах нет методов для получения доступа к конкретному элементу. Но зато есть методы `.values()`, `.keys()` и `.entries()`

## Получение значений множества. Методы values(), keys() и entries()

![[values(), keys(), entries()|values(), keys(), entries()]]

Получить доступ к значениям можно также, если применить spread к самому множеству:

```js
set.add('button')
	.add('active')
	.add('active');

console.log(...set); // 'button', 'active'
```

Чтобы получить массив, нужно spread обернуть в квадратные скобки или метод `Array.from(set)`. Туда передаем само множество.

```js

set.add('button')
	.add('active');

console.log([...set]); // ['button', 'active']
// или //
console.log(Array.from(set));
```
# Добавление элементов

![[_FE/2. JS Core/0. Типы данных/_Set/Методы/add()|add()]]

# Размер множества

![[_FE/2. JS Core/0. Типы данных/_Set/Методы/size()|size()]]

# Проверка на наличие элемента

![[_FE/2. JS Core/0. Типы данных/_Set/Методы/has()|has()]]

# Удаление элемента

![[_FE/2. JS Core/0. Типы данных/_Set/Методы/delete()|delete()]]

# Удаление ВСЕХ элементов

![[_FE/2. JS Core/0. Типы данных/_Set/Методы/clear()|clear()]]

# Перебор элементов множества

Множество можно перебрать, как и массив. Но так как у него нет индексов, применить обычный цикл `for` не выйдет. Но можно `for of`

```js
set.add('button')
	.add('active')
	.add('active');

for (value of set) console.log(value);
// или //
set.forEach(item => console.log(item));
```