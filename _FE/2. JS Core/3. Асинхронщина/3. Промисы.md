```table-of-contents
```
Обычно работа с асинхронщиной, по крайней мере, раньше, выполнялась через коллбеки. Они и были для этого придуманы. Например, у нас есть сервер, мы у него асинхронно запрашиваем данные, он их отдает и мы опять же асинхронно их выводим в консоль.

```js
console.log('Request data...');

setTimeout(() => { // имитируем запрос на сервер
  console.log('Preparing data...'); // эмулируем, что сервер готовит некие данные

  const backendData = { // Получили некоторые данные с сервера
    server: 'aws',
    port: 2000,
    status: 'working',
  };

  setTimeout(() => { // Асинхронно выводим данные после их получения
    backendData.modified = true;
    console.log('Data received', backendData);
  }, 2000);
  
}, 2000);
```

Это всё хорошо, но обычно кончается адом коллбеков. То есть, плохо. Решение --- ПРОМИСЫ!

## Промисы
Есть некий код, выполняющий некую работу и это занимает ненулевое время. Сколько времени -- неизвестно. И есть код, которому нужен результат работы первого.

В JS есть глобальный класс `Promise`, который связывает эти две сущности, делает доступным результат работы первого для второго. Его конструктор принимает в себя коллбек у которого есть два параметра `resolve` и `reject`. Внутри коллбека пишется асинхронный код, который будет выполняться. Параметры `resolve` и `reject` являются функциями-методами. Метод `resolve()` запускается когда асинхронный код был выполнен успешно, а в параметр передать результат выполнения промиса. `resolve()` запускается, когда промис выполнен с ошибкой. Может быть вызвано что-либо одно, `resolve()` и `reject()` не могут быть вызваны одновременно.

```js
const p = new Promise((resolve, reject) => {
	setTimeout(() => { // первая асинхронная операция
		console.log('Preparing data...'); // эмулируем, что сервер готовит некие данные
		
		const backendData = {
			server: 'aws',
			port: 2000,
			status: 'working',
		};
		resolve(); // говорим, что асинхронный код выполнен успешно.
	}, 2000)
})
```

## Свойства промисов
Вновь созданный через оператор `new` Промис возвращает объект, у которого помимо `resolve()`, `reject()`, `.then()` и `.catch()` есть ещё некоторые внутренние свойства:
- `state`
	- `pending` - начальное значение
	- `fulfilled` - выставляется, когда промис завершен успешно, через `resolved()`
	- `rejected` - выставляется, когда промис завершен не успешно, через `reject()`
- `result`
	- `undefined` - начальное значение
	- `value` - назначается через `resolve(value)`
	- `error` - назначается через `reject(error)`

Эти свойства внутренние и потому мы не имеем прямого к ним доступа. Работать с ними нужно через методы `.then()`, `.catch()`, `.finally()`

## Метод .then(), resolve()
У промисов есть методы. один из них это `.then()`. Он принимает в себя коллбек, который выполняется, когда успешно исполнится промис. То есть, когда будет вызван метод `resolve()`. Метод `resolve` может принимать в себя данные, переменные и т д, которые передадутся в метод `.then()`

```js
const p = new Promise((resolve, reject) => {
  setTimeout(() => {
    // первая асинхронная операция
    console.log('Preparing data...'); // эмулируем, что сервер готовит некие данные

    const backendData = {
      server: 'aws',
      port: 2000,
      status: 'working',
    };
    resolve(backendData); // передаем объект, полученный с сервера
  }, 2000);
});

// then получает переданные данные из resolve и кладёт их в переменную data
p.then(data => {
  const p2 = new Promise((resolve, reject) => {
    setTimeout(() => {
      data.modified = true;
      resolve(data);
    }, 2000);
  });

  p2.then(clientData => {
    console.log('Data received', clientData);
  });
});
```

## Цепочка из .then()
И в чём логгика? Ведь получается такая же вложенность. Есть один коллбек в виде then, второй коллбек - опять then... А в том, что вместо того, чтобы создавать новую переменную, можно возвращать из первого промиса новый промис и продолжить цепочку then, который получит данные из возвёрнутого промиса.

По сути, обработчик промиса возвращает новый промис результат которого передаётся дальше в `.then()`

```js ln=true
const p = new Promise((resolve, reject) => {
  setTimeout(() => {
    console.log('Preparing data...');

    const backendData = {
      server: 'aws',
      port: 2000,
      status: 'working',
    };
    resolve(backendData);
  }, 2000);
});

p.then(data => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      data.modified = true;
      resolve(data);
    }, 2000);
  })
    .then(clientData => {
      clientData.fromPromise = true;
      console.log('Data received', clientData);
      return clientData;
    })
    .then(data => {
      console.log('Modified', data);
    });
});
```

- `1` - Создаем промис, получаем данные с сервера. Резолвим на `10` строке, передаем полученные данные дальше
- `14` - Когда промис выполнился - создаем и возвращаем новый промис с новой асинхронной операцией. Модифицируем данные и резолвим, передаем их далее по цепочке `18`
- `21` - из возвращенного промиса на прошлом шаге получаем данные в переменную и модифицируем её на строке `22`
- Возвращать можно не только промисы, что мы и делаем на строке `24`
- На строке `26` принимаем новые данные и выводим их в консоль на `27`.

К одному промису можно навесить сколько угодно `.then()`, но это не будет являться цепочкой и всё это дело будет работать независимо, каждое из них получит одинаковое значение, которое вернул `resolve()` из промиса.

```javascript
let promise = new Promise(function(resolve, reject) {
  setTimeout(() => resolve(1), 1000);
});

promise.then(function(result) {
  alert(result); // 1
  return result * 2;
});

promise.then(function(result) {
  alert(result); // 1
  return result * 2;
});

promise.then(function(result) {
  alert(result); // 1
  return result * 2;
});
```

Это будет выглядеть вот так:
![[Pasted image 20240822162810.png]]

Если обработчик в `.then` (или в `catch/finally`, без разницы) возвращает промис, последующие элементы цепочки ждут, пока этот промис выполнится. Когда это происходит, результат его выполнения (или ошибка) передаётся дальше по цепочке.
![[Pasted image 20240822165203.png]]

## Обработка ошибок. Методы reject() и catch()
Промис может закончиться неудачей, тогда возникнет ошибка, которую можно перехватить методом `catch()`. Он вызывается когда промис попал в `reject()` и в него тоже можно передать данные, которые примет в себя метод `catch()`.

`reject()` может принимать аргумент любого типа, но лучше передавать туда объект ошибки Error или унаследованный от него.

```js ln=true
const p = new Promise((resolve, reject) => {
  setTimeout(() => {
    console.log('Preparing data...');

    const backendData = {
      server: 'aws',
      port: 2000,
      status: 'working',
    };
    resolve(backendData);
  }, 2000);
});

p.then(data => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      data.modified = true;
      reject(data);
    }, 2000);
  })
    .then(clientData => {
      clientData.fromPromise = true;
      console.log('Data received', clientData);
      return clientData;
    })
    .then(data => {
      console.log('Modified', data);
    });
}).catch(err => {
	console.error('Error', err)
});
```

При возникновении ошибки в любом из `then` в работу вступит ближайший по цепочке `catch`. И если его завершить успешно, то управление передастся ближайшему по цепочке успешному `then`. А если пробросить ошибку, то следующему обработчику `catch`.
### Необработанные ошибки
Если обработчика ошибок нет (забыли добавить или что-то пошло очень сильно не так, что появилась непредвиденная ошибка), то выстрелит событие `unhandledrejection`

```javascript
window.addEventListener('unhandledrejection', function(event) {
  // объект события имеет два специальных свойства:
  alert(event.promise); // [object Promise] - промис, который сгенерировал ошибку
  alert(event.reason); // Error: Ошибка! - объект ошибки, которая не была обработана
});

new Promise(function() {
  throw new Error("Ошибка!");
}); // нет обработчика ошибок
```
## Метод finally()
По аналогии с объектами ошибок есть метод finally(), который будет исполнен при любом исходе промиса. В него тоже загоняют коллбек. Метод `finally()` не имеет аргументов. Они ему и не нужны, потому что он не знает как завершится промис, успехом или неудачей. Он выполняет общие завершающие действия. Конец вечеринки. Или завершение сетевого соединения, например. Он также пропускает результат или ошибку дальше, к последующим обработчикам.

```javascript
new Promise((resolve, reject) => {
  setTimeout(() => resolve("value"), 2000);
})
  .finally(() => alert("Промис завершён")) // срабатывает первым
  .then(result => alert(result)); // <-- .then показывает "value"
```

```javascript
new Promise((resolve, reject) => {
  throw new Error("error");
})
  .finally(() => alert("Промис завершён")) // срабатывает первым
  .catch(err => alert(err));  // <-- .catch показывает ошибку
```

`finally()` также ничего не возвращает. А если насильно в нём что-то вернуть, то оно игнорируется.
## Фишки промисов
### Функция sleep
```js
const sleep = ms => {
  return new Promise((resolve) => {
    setTimeout(() => resolve(), ms);
  });
};

sleep(2000).then(() => console.log('After 2sec'))
```

Вместо `setTimeout` мы сделали функцию с указанной задержкой и последующими действиями после задержки.

### Метод all()

У глобального объекта Promise есть метод `.all()`
Он принимает массив промисов и ждёт, когда они все исполняться и только потом в `then()` выполняет какие-то действия. 

```js
Promise.all([sleep(2000), sleep(3000)])
	.then(() => {
		// ...Действия...
	})
```

Полезно, когда к серверу запросили набор данных по API из разных энд-поинтов и нужно дождать пока все они придут чтобы скомпоновать их и как-то все вместе обработать.

Кастомная реализация, передаем массив с набором промисов и на выходе нужно получить массив с результатами переданных промисов:

```js ln=true
function promiseAll(promises) {
  return new Promise((resolve, reject) => {
    const result = [];
    let counter = 0;

    promises.forEach((promise, i) => {
      promise.then(val => {
        result[i] = val;
        counter++;
        promises.length === counter ? resolve(result) : null;
      });
    });
  });
}
```

На вход передаем массив-аргумент с промисами. Возвращаем новый промис, в котором все элементы-промисы массива-аргумента пройдут через `forEach` и их результат занесётся в массив-результат. Присутствует счетчик, который увеличивается в `then` каждый раз как только исполняется очередной промис. Как только счетчик станет равен количеству переданных промисов -- резолвим изначальный промис ибо всё обработалось и исполнилось. Так как счетчик увеличивается внутри `then`, то это произойдёт только по исполнению соответствующего промиса.
### Метод race()
Этот метод принимает тоже массив из промисов и выстреливает, как только выполнился первый из промисов. Не по порядку в массиве, а по времени, то есть, самый быстрый. 

```js
Promise.race([sleep(2000), sleep(5000)]).then(() => {
	// ...Дейсвтия...
})
```