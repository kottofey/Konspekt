В JS всё есть объект. Функции, в том числе. У функции есть контекст вызова. 

Пример:
```js ln=true
function hello() {
	console.log('Hello', this);
}

const person = {
	name: "Roma",
	age: 30,
	sayHello: hello,
	logInfo: function(job, phone) {
		console.log(`Name is ${this.name}`);
		console.log(`Age is ${this.age}`);
		console.log(`Job is ${job}`);
		console.log(`Phone is ${phone}`);
	}
}

const natasha = {
	name: 'Natasha',
	age: 20,
}

person.sayHello();

person.logInfo();
person.logInfo.bind(natasha)();
person.logInfo.bind(natasha, 'Pharmacist', '+79781234567')();
person.logInfo.call(natasha, 'Pharmacist', '+79781234567');
person.logInfo.apply(natasha, ['Pharmacist', '+79781234567']);
```

Функция `hello()` выводит в консоль слово *Hello*, а затем объект в контексте которого была вызвана функция ибо на него **указывает ключевое слово `this`. Оно преобразовывается в объект, в контексте которого была вызвана функция**.

На строке `22` мы вызываем функцию `sayHello` для контекста объекта `person`. В консоль выведутся значения полей `name` и `age` для объекта `person`.

Усложним объект, на строках `9-14` создадим ключ со значением-функцией, которое выводит в консоль значения полей `name` и `age` для текущего объекта. Также в функцию будут передаваться значения для `job` и `phone`, которые будут выводиться в строках `12-13`. Уже без `this`, потому что, они предаются в параметрах и не зависят от контекста.

Далее мы создаем новый объект у которого есть поля `name` и `age`, но нет `logInfo`. Однако, его можно вызвать через объект, где она есть! Для этого воспользуемся методами `.call()`, `.bind(),` и `.apply()`.

Чтобы привязать к функции другой контекст есть метод `.bind(obj)`, в него передается объект `obj`, контекст которого нужно привязать.
## .bind()
Метод *не вызывает* функцию, но *возвращает новую функцию*, которая привязала к себе другой контекст. На строке `25` мы вызываем функцию из ключа `logInfo` у объекта `person` (при помощи `()` после описания функции) и при помощи метода `.bind()` передали в неё контекст объекта `natasha`. В результате выведется значение полей `name` и `age` для объекта `natasha`.

В метод `bind` можно передавать параметры через запятую после первого аргумента. Например, на строке `26` мы передаем значения для работы и телефона.

## call()
От `.bind()` отличается лишь тем, что функция вызывается сразу, без необходимости писать после метода `()`. Точно так же можно передать параметры через запятую. Пример на строке `27`, результат будет таким же. Количество переданных параметров может быть бесконечным.

## apply()
От `.bind()` отличается тем, что передаются два аргумента: контекст и массив с параметрами. Пример на строке `27`, результат будет таким же.

# Пример применения
Дан массив с числами, нужно написать функцию, которая изменит массив, перезаписав каждый элемент умножив его на заданное значение. 

```js ln=true
const arr = [1, 2, 3, 4, 5];

Array.prototype.multBy = function(n) {
	return this.map(function(i) {
		return i * n;
	});
}

console.log(arr.multBy(2)); // [2, 4, 6, 8, 10]
[1, 2, 3, 4, 5].multBy(3); // [3, 6, 9, 12, 15]
```

Метод `.prototype()` позволяет определить свой метод. Это метод глобального объекта, например, `Array`.