# Замыкания
При вызове функции в ней создаются переменные локальной области видимости, которые доступны только внутри функции. Снаружи мы не имеем к ним доступа. На хранение этих переменных выделяется память. Когда функция завершает своё выполнение — эта память освобождается.

При объявлении одной функции внутри другой, вложенная получает доступ к переменным и аргументам внешней. Именно за эти свойства вложенные функции в JS называют `замыканиями`, они замыкают на себе переменные и аргументы функции внутри которой определены.

```js
function makePhrase() {
	const greeting = 'Hello';

	function greet(name) {
		return `{greeting} ${name}!`;
	}

	return greet;
}

const sayHi = makePhrase();

sayHi('Maks'); // Hello Maks!
```

Чтобы создать замыкание, внутреннюю функцию нужно вернуть. Ссылка на переменную `greeting` остается внутри функции `makePhrase()` (внешней функции) и память не может быть освобождена, так как теперь замкнутая внутренняя функция `greet()` хранится в переменной `sayHi`

Для большей гибкости мы можем заменить переменную `greeting` на аргумент и использовать ее для создания других функций на основе `makePhrase()`. Например, `sayBye()`

```js
function makePhrase(greeting) {
	function greet(name) {
		return `{greeting} ${name}!`;
	}

	return greet;
}

const sayHi = makePhrase('Hello');

sayHi('Maks'); // Hello Maks

const sayBye = makePhrase('Bye');

sayBye('Anna'); // Bye Anna
```

Каждое замыкание будет иметь свои переменные, переданные в аргументах и не будут зависеть от переменных других функций.

Хорошим примером использования замыканий является замена темы при клике. Вызов функции `changeTheme()` вернет нам функцию, которая сработает в дальнейшем при клике на кнопку смены темы.

```js
function changeThemeColor) {
	return () => {
		document.body.style
			.background = color;
	}
}

document.getElementById('set-black')
	.onclick = changeTheme('black');

document.getElementById('set-white')
	.onclick = changeTheme('white');
```
___
# Асинхронность
Некоторые функции выполняются асинхронно, то есть, не в момент ее создания, а когда-нибудь потом. Поэтому, в момент выполнения кода значение переменной может уже измениться. Чтобы избавиться от этой проблемы, нужно создать отдельную область видимости. Так все переменные будут под контролем и замыкания не позволят потерять необходимые значения.

В примере у нас есть фотогалерея с одной большой фоткой и рядом превьюшек под ней. 
```js
var thumbnails = document.querySelectorAll('.gallery__photo-preview'); // Помещаем коллекцию с превью в переменную
var fullPhoto = document.querySelector('.full-photo'); // Помещаем полную фотку в пременную

var addThumbnailClickHandler = function (thumbnail, photo) {
  thumbnail.addEventListener('click', function () {
    fullPhoto.src = photo;
  }); // создаем замыкание внутри обработчика кликов по превьюшкам
};

for (var i = 0; i < thumbnails.length; i++) {
  addThumbnailClickHandler(thumbnails[i], photos[i]);
} // в цикле присваиваем личное замыкание-обработчик кликов каждой превьюшке. Клик по каждой превью вызовет свой собственный обработчик.
```