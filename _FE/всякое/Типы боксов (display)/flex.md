### Тип: FLEX
Задается свойством `display: flex` или `display: inline-flex` Элементы флекс-контейнера выстраиваются друг за другом вдоль главной оси. По-умолчанию, это — слева направо.
![Схема главной оси флекс-контейнера](https://htmlacademy.ru/assets/courses/359/img/scheme9.svg)

Изначально ширина всех флекс-элементов ужимается до содержимого, если явно не указана ширина. Это можно сделать свойством width. Оно не учитывает отступы и границу и задает ширину только содержимого. Пример:
```css
.box {
  width: 100px;
  padding-left: 20px;
  padding-right: 30px;
  border: 5px solid black;
}
```
В этом случае полная ширина бокса окажется `160px`, потому что ширина содержимого сложится с шириной отступов и рамок: `100px` + `20px` + `30px` + `5px` + `5px` (рамка справа и слева).

#### Выравнивание по главной оси (равномерное)
Если ширина флекс-контейнера больше суммы ширин его элементов, то остается свободное пространство. Можно выровнять с помощью свойства `justify-content`. Может принимать седующие значения:
- `flex-start` — флекс-элементы располагаются в начале главной оси (по умолчанию — слева);
- `flex-end` — флекс-элементы располагаются в конце главной оси (по умолчанию — справа);
- `center` — флекс-элементы располагаются в центре главной оси;
- `space-around` — свободное пространство распределяется вокруг всех флекс-элементов;
- `space-between` — свободное пространство распределяется между флекс-элементами, при этом первый и последний элемент прижимаются к краям флекс-контейнера.
#### Выравнивание по главной оси (неравномерное)
Если расстояния между флекс-элементами неравномерные, то `justify-content` не поможет, нужны `margin`. Например, есть три элемента: 
![Макет подвала](https://htmlacademy.ru/assets/courses/359/img/port_scr8.svg)
```css
.contacts {
  width: 160px;
  margin-right: auto; /*отталкивает два других элемента вправо*/
}

.copyright {
  width: 170px;
}

.logo {
  width: 70px;
  margin-left: 20px; /*устанавливает зазор между 2 и 3 элементом*/
}
```
#### Выравнивание по горизонтали
Чтобы сработало, нужно чтобы элемент был уже, чем его родитель. Тогда можно указать свойству `margin` значение `auto`, чтобы браузер сам расчитал отступы.
![Схема выравнивания по горизонтали](https://htmlacademy.ru/assets/courses/359/img/scheme7.svg)

Таким образом можно выровнять только блочные боксы и только по-горизонтали. Строчные выровнять не выйдет.

#### Выравнивание по вертикали
Флексы можно выранивать по вертикали внешними отступами. 
![Схема выравнивания по вертикали](https://htmlacademy.ru/assets/courses/359/img/scheme8.svg)

**Для выравнивания отдельного флекс-элемента поперёк главной оси можно также использовать свойство `align-self`.**

#### flex-wrap
Может так случиться, что количество элементов переполнит ширину экрана и появится горизонтальная полоса прокрутки.

Чтобы привязать контейнер к ширине его родителя нужно задать свойство `flex‑wrap`
![[flex-wrap]]

Внешние отступы (margin) у флексов складываются:
![[scheme_flex-grid01.svg]]

Обычно с одной стороны всех флекс-элементов отступы обнуляют, а с другой указывают полную величину. То есть, вместо `5 снизу` + `10 сверху`, `10 сверху` убирают, и указывают `снизу 15px`

#### Flex-basis
![[flex-basis]]
#### Flex-grow и flex-shrink
![[flex-grow]]

![[flex-shrink]]

Свойства `flex-grow` вступает в работу, когда имеется свободное пространство, а `flex-shrink`, когда наоборот, контейнер переполнен.
#### Расчеты для flex-grow и flex-shrink
##### Когда контейнер переполняется
Посчитаем, на сколько сожмутся элементы, если контейнер переполнился.

Например, у нас есть контейнер шириной **1100px** и 6 элементов с `flex-basis: 200px`. Выходит, что все элементы займут: $$6 \times 200 = 1200px$$
Переполнение составит: $$|1100 - 1200| = 100px$$
Оно и распределится поровну между элементами, если не указаны модификаторы растяжения или сжатия.

```html
<div class="flex-container">
	<div class="el el-1"></div>
	<div class="el el-2"></div>
	<div class="el el-3"></div>
	<div class="el el-4"></div>
	<div class="el el-5"></div>
	<div class="el el-6"></div>
</div>
```

```css
.flex.container {
	display: flex;
	width: 1100px;
}

.el {
	flex-basis: 200px;
}

.el-1 {
	flex-shrink: 3;
}
.el-2 {
	flex-shrink: 2;
}
.el-3,
.el-4,
.el-5,
.el-6 {
	flex-shrink: 1;
}
```

Посчитаем вес элементов: $$1\times3\times200 + 1\times2\times200 + 4\times1\times200 = 1800px$$
>Первый элемент с `flex-shrink: 3`, второй элемент с `flex-shrink: 2` и остальные четыре с `flex-shrink: 1`. Перемножили на их значения flex-basis и сложили.

Итого, мы имеем:
- Переполнение 100px
- Общий вес элементов 1800px
- flex-basis каждого элемента 200px (у каждого элемента может быть свой)
- flex-shrink, у каждого элемента - свой

Формула величины сжатия элемента (величина, ***на*** которую элемент уменьшится): $$\text{flex-basis} \times \text{переполнение} \times \text{flex-shrink} \div \text{общий вес}$$
Для первого элемента: $$200 \times 100 \times 3 \div 1800 = 33.33$$
Для второго элемента: $$200 \times 100 \times 2 \div 1800 = 22.22$$
Для 3, 4, 5 и 6 элементов: $$200 \times 100 \times 1 \div 1800 = 11.11$$
Далее отнимаем соответствующий полученную величину от значения flex-basis этого элемента, чтобы вычислить его размер:
1) $200 - 33.33 = 166.67px$
2) $200-22.22=177.78px$
3) $200-11.11=188.89px$

##### Когда контейнер заполнен не полностью
```html
<div class="flex-container">
	<div class="el el-1"></div>
	<div class="el el-2"></div>
	<div class="el el-3"></div>
	<div class="el el-4"></div>
	<div class="el el-5"></div>
	<div class="el el-6"></div>
</div>
```

```css
.flex.container {
	display: flex;
	width: 800px;
}

.el {
	flex-basis: 100px;
}

.el-1 {
	flex-grow: 3;
}
.el-2 {
	flex-grow: 2;
}
.el-3,
.el-4,
.el-5,
.el-6 {
	flex-grow: 1;
}
```

Ширина всех элементов: $$6\times100=600px$$
Свободное место в контейнере: $$800-600=200px$$
